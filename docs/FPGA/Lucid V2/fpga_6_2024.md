---
layout: default
permalink: /fpga/fpga_6_2024
title: WS2812B 
description: Tips on how to use instructor's drivers 
parent: Lucid V2
grand_parent: 1D&2D Project (FPGA)
nav_order:  6
---


* TOC
{:toc}

**50.002 Computation Structures**
<br>
Information Systems Technology and Design
<br>
Singapore University of Technology and Design


## Introduction to FPGA Drivers for LED Displays and Controllers

Driving LED displays efficiently requires understanding various communication protocols and hardware interfaces. In this guide, we will explore how to control **WS2812B addressable LEDs, HUB75 RGB LED matrices, 74HC595 shift registers, and MAX7219 LED drivers** using an FPGA.

1. **[WS2812B](https://cdn-shop.adafruit.com/datasheets/WS2812B.pdf) (Addressable RGB LEDs)**  
   WS2812B LEDs are individually addressable RGB LEDs with an integrated driver chip. They use a single-wire **timing-based protocol** to transmit color data in a daisy-chain fashion. Since precise timing is required, controlling WS2812B from an FPGA involves generating **accurate** pulse widths to match the protocol specifications.

2. **[HUB75](https://learn.adafruit.com/32x16-32x32-rgb-led-matrix/overview) RGB LED Matrix**  
   The HUB75 interface is commonly used in large RGB LED panel displays. It utilizes a **multiplexed row-column addressing scheme**, requiring multiple control signals, including row selection, RGB data lines, and clock signals. Driving a HUB75 matrix with an FPGA involves sequentially scanning rows while updating pixel data at high speed to achieve a flicker-free display.

3. **[74HC595](https://www.diodes.com/assets/Datasheets/74HC595.pdf) Shift Register**  
   The **74HC595** is an **8-bit serial-in, parallel-out shift register** used for expanding output pins. It is often used in LED matrix displays to control multiple LEDs with fewer FPGA I/O pins. The FPGA shifts data into the register using a **serial clock (SCK) and latch enable (LE) signal**, allowing efficient control of large LED arrays.

4. **[MAX7219](https://www.analog.com/media/en/technical-documentation/data-sheets/max7219-max7221.pdf) LED Driver**  
   The **MAX7219** is a serially interfaced **LED driver** designed for controlling 7-segment displays, dot matrices, and bar graphs. It simplifies driving multiple LEDs by handling current regulation and multiplexing internally. Communication with the MAX7219 is done using a **simple SPI-like protocol**, making it an efficient solution for driving multiple digits or LED segments with minimal FPGA resources.

Each of these devices requires a *different* approach to interfacing with an FPGA. This guide will cover the key concepts, timing requirements, and FPGA implementation strategies for **WS2812B**. You can find other guides in the sidebar. 


## **Driving WS2812B LEDs with an FPGA**  

### **Overview**
WS2812B LEDs are **individually addressable RGB LEDs** with an integrated driver chip. They use a **single-wire protocol** to receive data and control color. Since each LED in a strip or matrix can store its own color information, a long sequence of LEDs can be controlled with just **one data pin**.

### Connection

<img src="{{ site.baseurl }}/docs/FPGA/Lucid V2/images/WS2812B-Strip-Pinout.png.webp"  class="center_seventy"/>

Connect Din directly to FPGA GPIO Pin, GND to FPGA GND, and +5V to FPGA +5V Ports. If you use external power, ensure that GND is shared between the FPGA and WS2812B.

### **How WS2812B Works**
- Each LED contains **a red, green, and blue LED** with **8-bit brightness control** (0–255).
- Data is sent **serially** in **24-bit GRB format**:
  - **8 bits for Green**
  - **8 bits for Red**
  - **8 bits for Blue**
- The LEDs **store** the data and pass the remaining data down the strip.
- A **reset signal** (low for >50 µs) tells the LEDs to update their colors.

### **Communication Protocol**
WS2812B uses a **pulse-width encoding scheme** to differentiate between `1` and `0`:

| Bit Value | High Time | Low Time | Total Period |
|-----------|----------|----------|-------------|
| **0**     | 0.4 µs   | 0.85 µs  | 1.25 µs     |
| **1**     | 0.8 µs   | 0.45 µs  | 1.25 µs     |

- The **timing must be precise**, requiring accurate pulse generation from the FPGA.

For a 100MHz clock, we have: 

| Bit Value | High Time | Low Time | Total Period | High Cycles (100 MHz) | Low Cycles (100 MHz) | Total Cycles |
|-----------|----------|----------|-------------|-----------------------|-----------------------|--------------|
| **0**     | 0.4 µs   | 0.85 µs  | 1.25 µs     | **40 cycles**         | **85 cycles**         | **125 cycles** |
| **1**     | 0.8 µs   | 0.45 µs  | 1.25 µs     | **80 cycles**         | **45 cycles**         | **125 cycles** |
| **RESET** | **Low for >50 µs** | | | | **5000 cycles** (minimum) |

**Breakdown**
- **Each WS2812B bit takes 1.25 µs = 125 cycles at 100 MHz.**
- A **logic ‘0’**:
  - High for **40 cycles** (0.4 µs)
  - Low for **85 cycles** (0.85 µs)
- A **logic ‘1’**:
  - High for **80 cycles** (0.8 µs)
  - Low for **45 cycles** (0.45 µs)
- **Reset signal**:
  - Hold data line **low for at least 50 µs** (5000 cycles at 100 MHz).


### **Sending Data to WS2812B**
1. **Send a 24-bit color value for each LED** in the GRB format.
2. **Ensure correct timing** of `1` and `0` bits using precise pulse widths.
3. **Send a reset signal** (low for >50 µs) after **all** LEDs have received their data.






